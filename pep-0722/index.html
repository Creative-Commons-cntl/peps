
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="color-scheme" content="light dark">
    <title>PEP 722 – Dependency specification for single-file scripts | peps.python.org</title>
    <link rel="shortcut icon" href="../_static/py.png">
    <link rel="canonical" href="https://peps.python.org/pep-0722/">
    <link rel="stylesheet" href="../_static/style.css" type="text/css">
    <link rel="stylesheet" href="../_static/mq.css" type="text/css">
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" media="(prefers-color-scheme: light)" id="pyg-light">
    <link rel="stylesheet" href="../_static/pygments_dark.css" type="text/css" media="(prefers-color-scheme: dark)" id="pyg-dark">
    <link rel="alternate" type="application/rss+xml" title="Latest PEPs" href="https://peps.python.org/peps.rss">
    <meta name="description" content="Python Enhancement Proposals (PEPs)">
</head>
<body>
    
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-sun-half" viewBox="0 0 24 24" pointer-events="all">
    <title>Following system colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="9"></circle>
      <path d="M12 3v18m0-12l4.65-4.65M12 14.3l7.37-7.37M12 19.6l8.85-8.85"></path>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected dark colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected light colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
</svg>
    <script>

        document.documentElement.dataset.colour_scheme = localStorage.getItem("colour_scheme") || "auto"
    </script>
    <section id="pep-page-section">
        <header>
            <h1>Python Enhancement Proposals</h1>
            <ul class="breadcrumbs">
                <li><a href="https://www.python.org/" title="The Python Programming Language">Python</a> &raquo; </li>
                <li><a href="../pep-0000/">PEP Index</a> &raquo; </li>
                <li>PEP 722</li>
            </ul>
            <button id="colour-scheme-cycler" onClick="setColourScheme(nextColourScheme())">
                <svg aria-hidden="true" class="colour-scheme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-dark"><use href="#svg-moon"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-light"><use href="#svg-sun"></use></svg>
                <span class="visually-hidden">Toggle light / dark / auto colour theme</span>
            </button>
        </header>
        <article>
            <section id="pep-content">
<h1 class="page-title">PEP 722 – Dependency specification for single-file scripts</h1>
<dl class="rfc2822 field-list simple">
<dt class="field-odd">Author<span class="colon">:</span></dt>
<dd class="field-odd">Paul Moore &lt;p.f.moore&#32;&#97;t&#32;gmail.com&gt;</dd>
<dt class="field-even">PEP-Delegate<span class="colon">:</span></dt>
<dd class="field-even">Brett Cannon &lt;brett&#32;&#97;t&#32;python.org&gt;</dd>
<dt class="field-odd">Discussions-To<span class="colon">:</span></dt>
<dd class="field-odd"><a class="reference external" href="https://discuss.python.org/t/29905">Discourse thread</a></dd>
<dt class="field-even">Status<span class="colon">:</span></dt>
<dd class="field-even"><abbr title="Proposal under active discussion and revision">Draft</abbr></dd>
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><abbr title="Normative PEP with a new feature for Python, implementation change for CPython or interoperability standard for the ecosystem">Standards Track</abbr></dd>
<dt class="field-even">Topic<span class="colon">:</span></dt>
<dd class="field-even"><a class="reference external" href="../topic/packaging/">Packaging</a></dd>
<dt class="field-odd">Created<span class="colon">:</span></dt>
<dd class="field-odd">19-Jul-2023</dd>
<dt class="field-even">Post-History<span class="colon">:</span></dt>
<dd class="field-even"><a class="reference external" href="https://discuss.python.org/t/29905" title="Discourse thread">19-Jul-2023</a></dd>
</dl>
<hr class="docutils" />
<section id="contents">
<details><summary>Table of Contents</summary><ul class="simple">
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#motivation">Motivation</a></li>
<li><a class="reference internal" href="#rationale">Rationale</a></li>
<li><a class="reference internal" href="#specification">Specification</a><ul>
<li><a class="reference internal" href="#example">Example</a></li>
</ul>
</li>
<li><a class="reference internal" href="#backwards-compatibility">Backwards Compatibility</a></li>
<li><a class="reference internal" href="#security-implications">Security Implications</a></li>
<li><a class="reference internal" href="#how-to-teach-this">How to Teach This</a></li>
<li><a class="reference internal" href="#recommendations">Recommendations</a></li>
<li><a class="reference internal" href="#reference-implementation">Reference Implementation</a></li>
<li><a class="reference internal" href="#rejected-ideas">Rejected Ideas</a><ul>
<li><a class="reference internal" href="#why-not-include-other-metadata">Why not include other metadata?</a></li>
<li><a class="reference internal" href="#why-not-use-a-more-standard-data-format-e-g-toml">Why not use a more standard data format (e.g., TOML)?</a></li>
<li><a class="reference internal" href="#why-not-embed-a-pyproject-toml-file-in-the-script">Why not embed a <code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code> file in the script?</a></li>
<li><a class="reference internal" href="#why-not-just-set-up-a-python-project-with-a-pyproject-toml">Why not just set up a Python project with a <code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code>?</a></li>
<li><a class="reference internal" href="#why-not-use-a-requirements-file-for-dependencies">Why not use a requirements file for dependencies?</a></li>
<li><a class="reference internal" href="#why-not-use-possibly-restricted-python-syntax">Why not use (possibly restricted) Python syntax?</a></li>
<li><a class="reference internal" href="#should-scripts-be-able-to-specify-a-package-index">Should scripts be able to specify a package index?</a></li>
<li><a class="reference internal" href="#what-about-local-dependencies">What about local dependencies?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#open-issues">Open Issues</a></li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>
</details></section>
<section id="abstract">
<h2><a class="toc-backref" href="#abstract" role="doc-backlink">Abstract</a></h2>
<p>This PEP specifies a format for including 3rd-party dependencies in a
single-file Python script.</p>
</section>
<section id="motivation">
<h2><a class="toc-backref" href="#motivation" role="doc-backlink">Motivation</a></h2>
<p>Not all Python code is structured as a “project”, in the sense of having its own
directory complete with a <code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code> file, and being built into an
installable distribution package. Python is also routinely used as a scripting
language, with Python scripts as a (better) alternative to shell scripts, batch
files, etc. When used to create scripts, Python code is typically stored as a
single file, often in a directory dedicated to such “utility scripts”, which
might be in a mix of languages with Python being only one possibility among
many. Such scripts may be shared, often by something as simple as email, or a
link to a URL such as a Github gist. But they are typically <em>not</em> “distributed”
or “installed” as part of a normal workflow.</p>
<p>One problem when using Python as a scripting language in this way is how to run
the script in an environment that contains whatever third party dependencies are
required by the script. There is currently no standard tool that addresses this
issue, and this PEP does <em>not</em> attempt to define one. However, any tool that
<em>does</em> address this issue will need to know what 3rd party dependencies a script
requires. By defining a standard format for storing such data, existing tools,
as well as any future tools, will be able to obtain that information without
requiring users to include tool-specific metadata in their scripts.</p>
</section>
<section id="rationale">
<h2><a class="toc-backref" href="#rationale" role="doc-backlink">Rationale</a></h2>
<p>Because a key requirement is writing single-file scripts, and simple sharing by
giving someone a copy of the script, the PEP defines a mechanism for embedding
dependency data <em>within the script itself</em>, and not in an external file.</p>
<p>We define the concept of a <em>metadata block</em> that contains information about a
script. The only type of metadata defined here is dependency information, but
making the concept general allows expansion in the future, should it be needed.</p>
<p>In order to identify metadata blocks, the script can simply be read as a text
file. This is deliberate, as Python syntax changes over time, so attempting to
parse the script as Python code would require choosing a specific version of
Python syntax. Also, it is likely that at least some tools will not be written
in Python, and expecting them to implement a Python parser is too much of a
burden.</p>
<p>However, to avoid needing changes to core Python, the format is designed to
appear as comments to the Python parser. It is possible to write code where a
metadata block is <em>not</em> interpreted as a comment (for example, by embedding it
in a Python multi-line string), but such uses are discouraged and can easily be
avoided assuming you are not deliberately trying to create a pathological
example.</p>
<p>A <a class="reference external" href="https://dbohdan.com/scripts-with-dependencies">review</a> of how other languages allow scripts to specify
their dependencies shows that a “structured comment” like this is a
commonly-used approach.</p>
</section>
<section id="specification">
<h2><a class="toc-backref" href="#specification" role="doc-backlink">Specification</a></h2>
<p>Any Python script may contain one or more <em>metadata blocks</em>. Metadata blocks are
identified by reading the script <em>as a text file</em> (i.e., the file is not parsed
as Python source code), looking for contiguous blocks of lines that start with
the identifying characters <code class="docutils literal notranslate"><span class="pre">##</span></code>. Whitespace is not allowed before the
identifying <code class="docutils literal notranslate"><span class="pre">##</span></code>. More than one metadata block may exist in a Python file.</p>
<p>Tools reading dependency blocks MAY respect the standard Python encoding
declaration. If they choose not to do so, they MUST process the file as UTF-8.</p>
<p>Within a metadata block, whitespace after the <code class="docutils literal notranslate"><span class="pre">##</span></code> and at the end of the line
is ignored, and blank lines are ignored. The first line of a metadata block is
special, and identifies the type of block. This line MUST contain a colon
character, <code class="docutils literal notranslate"><span class="pre">:</span></code>. If the colon is not present, the block is not considered to be
a metadata block, and tools MUST ignore it. The block type is all of the text on
the initial line, up to the colon. There must be no whitespace before the colon.
The initial line MAY contain text after the colon. How this is interpreted
depends on the block type. Block types MUST be treated as case sensitive.</p>
<p>The interpretation of any lines in a metadata block after the initial
identifying line, is defined by the type of block.</p>
<p>Tools MUST ignore any blocks with types they do not handle.</p>
<p>Block types starting with the characters <code class="docutils literal notranslate"><span class="pre">X-</span></code> are reserved for the user, and
MUST NOT be given a meaning in any future standard.</p>
<p>Otherwise, the only defined block type is <code class="docutils literal notranslate"><span class="pre">Script</span> <span class="pre">Dependencies</span></code>. For this
block type,</p>
<ol class="arabic simple">
<li>Text after the colon on the initial line is NOT allowed.</li>
<li>All subsequent lines MUST contain <a class="pep reference internal" href="../pep-0508" title="PEP 508 – Dependency specification for Python Software Packages">PEP 508</a> requirement
specifiers, one per line.</li>
</ol>
<p>There SHOULD only be a single <code class="docutils literal notranslate"><span class="pre">Script</span> <span class="pre">Dependencies</span></code> block in the file. Tools
consuming dependency data MAY simply process the first such block found. This
avoids the need for tools to process more data than is necessary.</p>
<p>Consumers MUST validate that at a minimum, all dependencies start with a
<code class="docutils literal notranslate"><span class="pre">name</span></code> as defined in <a class="pep reference internal" href="../pep-0508" title="PEP 508 – Dependency specification for Python Software Packages">PEP 508</a>, and they MAY validate that all dependencies
conform fully to <a class="pep reference internal" href="../pep-0508" title="PEP 508 – Dependency specification for Python Software Packages">PEP 508</a>. They MUST fail with an error if they find an
invalid specifier.</p>
<section id="example">
<h3><a class="toc-backref" href="#example" role="doc-backlink">Example</a></h3>
<p>The following is an example of a script with an embedded dependency block:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># In order to run, this script needs the following 3rd party libraries</span>
<span class="c1">#</span>
<span class="c1">## Script Dependencies:</span>
<span class="c1">##    requests</span>
<span class="c1">##    rich</span>

<span class="kn">import</span> <span class="nn">requests</span>
<span class="kn">from</span> <span class="nn">rich.pretty</span> <span class="kn">import</span> <span class="n">pprint</span>

<span class="n">resp</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;https://peps.python.org/api/peps.json&quot;</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">resp</span><span class="o">.</span><span class="n">json</span><span class="p">()</span>
<span class="n">pprint</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">[</span><span class="s2">&quot;title&quot;</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">()][:</span><span class="mi">10</span><span class="p">])</span>
</pre></div>
</div>
</section>
</section>
<section id="backwards-compatibility">
<h2><a class="toc-backref" href="#backwards-compatibility" role="doc-backlink">Backwards Compatibility</a></h2>
<p>As metadata blocks take the form of a structured comment, they can be added
without altering the meaning of existing code.</p>
<p>It is possible that a comment may already exist which matches the form of a
metadata block. While the use of a double <code class="docutils literal notranslate"><span class="pre">#</span></code> prefix is intended to minimise
this risk, it is still possible.</p>
<p>Because tools must ignore unrecognised metadata types, the only potential issue
we need to consider is script dependencies. In that case, a tool might read the
wrong dependencies. In practice, though, this is unlikely to happen, as (a) the
header text (<code class="docutils literal notranslate"><span class="pre">Script</span> <span class="pre">Dependencies:</span></code>) is fairly unusual, and (b) any following
lines are unlikely to conform to <a class="pep reference internal" href="../pep-0508" title="PEP 508 – Dependency specification for Python Software Packages">PEP 508</a> unless they <em>are</em> dependencies.</p>
<p>In the rare case where an existing comment would be interpreted incorrectly as a
dependency block, this can be addressed by adding an actual dependency block
(which can be empty if the script has no dependencies) earlier in the code.</p>
</section>
<section id="security-implications">
<h2><a class="toc-backref" href="#security-implications" role="doc-backlink">Security Implications</a></h2>
<p>If a script containing a dependency block is run using a tool that automatically
installs dependencies, this could cause arbitrary code to be downloaded and
installed in the user’s environment.</p>
<p>The risk here is part of the functionality of the tool being used to run the
script, and as such should already be addressed by the tool itself. The only
additional risk introduced by this PEP is if an untrusted script with a
dependency block is run, when a potentially malicious dependency might be
installed. This risk is addressed by the normal good practice of reviewing code
before running it.</p>
</section>
<section id="how-to-teach-this">
<h2><a class="toc-backref" href="#how-to-teach-this" role="doc-backlink">How to Teach This</a></h2>
<p>The format is intended to be close to how a developer might already specify
script dependencies in an explanatory comment. The required structure is
deliberately minimal, and the concept of using a special comment marker (<code class="docutils literal notranslate"><span class="pre">##</span></code>
in this case) is not unusual (the “shebang” line in a Unix shell script is an
example).</p>
<p>Users will need to know how to write Python dependency specifiers. This is
covered by <a class="pep reference internal" href="../pep-0508" title="PEP 508 – Dependency specification for Python Software Packages">PEP 508</a>, but for simple examples (which is expected to be the norm
for inexperienced users) the syntax is either just a package name, or a name and
a version restriction, which is fairly well-understood syntax.</p>
<p>Users will also know how to <em>run</em> a script using a tool that interprets
dependency data. This is not covered by this PEP, as it is the responsibility of
such a tool to document how it should be used.</p>
<p>Note that the core Python interpreter does <em>not</em> interpret dependency blocks.
This may be a point of confusion for beginners, who try to run <code class="docutils literal notranslate"><span class="pre">python</span>
<span class="pre">some_script.py</span></code> and do not understand why it fails. This is no different than
the current status quo, though, where running a script without its dependencies
present will give an error.</p>
<p>In general, it is assumed that if a beginner is given a script with dependencies
(regardless of whether they are specified in a dependency block), the person
supplying the script should explain how to run that script, and if that involves
using a script runner tool, that should be noted.</p>
</section>
<section id="recommendations">
<h2><a class="toc-backref" href="#recommendations" role="doc-backlink">Recommendations</a></h2>
<p>This section is non-normative and simply describes “good practices” when using
metadata blocks.</p>
<p>Scripts should, in general, place metadata blocks at the top of the file,
either immediately after any shebang line, or straight after the script
docstring. In particular, the metadata block should always be placed before
any executable code in the file. This makes it easy for the human reader to
locate the metadata block, and allows tools to only read the minimum necessary
to identify them.</p>
</section>
<section id="reference-implementation">
<h2><a class="toc-backref" href="#reference-implementation" role="doc-backlink">Reference Implementation</a></h2>
<p>Code to implement this proposal in Python is fairly straightforward, so the
reference implementation can be included here.</p>
<p>A parser that reads <em>only</em> the script dependency metadata.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">tokenize</span>
<span class="kn">from</span> <span class="nn">packaging.requirements</span> <span class="kn">import</span> <span class="n">Requirement</span>

<span class="n">DEPENDENCY_BLOCK_MARKER</span> <span class="o">=</span> <span class="s2">&quot;Script Dependencies:&quot;</span>

<span class="k">def</span> <span class="nf">read_dependency_block</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
   <span class="c1"># Use the tokenize module to handle any encoding declaration.</span>
   <span class="k">with</span> <span class="n">tokenize</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
      <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;##&quot;</span><span class="p">):</span>
               <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
               <span class="k">if</span> <span class="n">line</span> <span class="o">==</span> <span class="n">DEPENDENCY_BLOCK_MARKER</span><span class="p">:</span>
                  <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
                     <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;##&quot;</span><span class="p">):</span>
                           <span class="k">break</span>
                     <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                     <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span><span class="p">:</span>
                           <span class="k">continue</span>
                     <span class="c1"># Try to convert to a requirement. This will raise</span>
                     <span class="c1"># an error if the line is not a PEP 508 requirement</span>
                     <span class="k">yield</span> <span class="n">Requirement</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
                  <span class="k">break</span>
</pre></div>
</div>
<p>A full metadata block parser that returns all metadata blocks in a script.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">tokenize</span>
<span class="kn">from</span> <span class="nn">packaging.requirements</span> <span class="kn">import</span> <span class="n">Requirement</span>

<span class="k">def</span> <span class="nf">read_metadata_blocks</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
   <span class="c1"># Use the tokenize module to handle any encoding declaration.</span>
   <span class="k">with</span> <span class="n">tokenize</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
      <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;##&quot;</span><span class="p">):</span>
               <span class="n">block_type</span><span class="p">,</span> <span class="n">sep</span><span class="p">,</span> <span class="n">extra</span> <span class="o">=</span> <span class="n">line</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)</span>
               <span class="k">if</span> <span class="ow">not</span> <span class="n">sep</span><span class="p">:</span>
                  <span class="k">continue</span>
               <span class="n">block_data</span> <span class="o">=</span> <span class="p">[]</span>
               <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
                  <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;##&quot;</span><span class="p">):</span>
                        <span class="k">break</span>
                  <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                  <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span><span class="p">:</span>
                        <span class="k">continue</span>
                  <span class="n">block_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
               <span class="k">yield</span> <span class="n">block_type</span><span class="p">,</span> <span class="n">extra</span><span class="p">,</span> <span class="n">block_data</span>
</pre></div>
</div>
<p>A format similar to the one proposed here is already supported <a class="reference external" href="https://github.com/pypa/pipx/pull/916">in pipx</a> and in <a class="reference external" href="https://pypi.org/project/pip-run/">pip-run</a>.</p>
</section>
<section id="rejected-ideas">
<h2><a class="toc-backref" href="#rejected-ideas" role="doc-backlink">Rejected Ideas</a></h2>
<section id="why-not-include-other-metadata">
<h3><a class="toc-backref" href="#why-not-include-other-metadata" role="doc-backlink">Why not include other metadata?</a></h3>
<p>The “metadata block” format is designed to allow additional metadata types, but
none are defined at this time. Currently, the only data used by tools is
dependency information, and therefore this is the only information required by
this standard. If, in future, a need is identified for other data to be
standardised, adding further metadata types is straightforward.</p>
<p>By reserving metadata types starting with <code class="docutils literal notranslate"><span class="pre">X-</span></code>, the specification allows
experimentation with additional data <em>before</em> standardising.</p>
<p>Two particular cases are a script version number, and the version of Python
needed to run the script.</p>
<p>In the case of the version number, there are no known tools that try to extract
version information from scripts, so there is no immediate benefit to having the
version as metadata, rather than, for example, as a normal comment or a
<code class="docutils literal notranslate"><span class="pre">__version__</span></code> attribute (see <a class="pep reference internal" href="../pep-0396" title="PEP 396 – Module Version Numbers">PEP 396</a>). If it becomes common for tools to
want to introspect script versions, this could be added at a later date.</p>
<p>In the case of the Python version, existing tools provide a means for the <em>user</em>
to specify what Python interpreter to use when running the script (for example,
<code class="docutils literal notranslate"><span class="pre">pipx</span> <span class="pre">run</span></code> provides the <code class="docutils literal notranslate"><span class="pre">--python</span></code> command line option), but they do not
typically allow the <em>script</em> to define a version range, and then automatically
pick an interpreter based on that. Having a “supported version” for a script may
allow the tool to provide better error messages when run with an inappropriate
interpreter, but currently, this is largely a theoretical benefit. Again, it is
something that can be added later if it becomes a commonly requested feature.</p>
</section>
<section id="why-not-use-a-more-standard-data-format-e-g-toml">
<h3><a class="toc-backref" href="#why-not-use-a-more-standard-data-format-e-g-toml" role="doc-backlink">Why not use a more standard data format (e.g., TOML)?</a></h3>
<p>First of all, the only practical choice for an alternative format is TOML.
Python packaging has standardised on TOML for structured data, and using a
different format, such as YAML or JSON, would add complexity and confusion for
no real benefit.</p>
<p>So the question is essentially, “why not use TOML?”</p>
<p>The key idea behind the “metadata block” format is to define something that
reads naturally as a comment in the script. Dependency data is useful both for
tools and for the human reader, so having a human readable format is beneficial.
On the other hand, TOML of necessity has a syntax of its own, which distracts
from the underlying data.</p>
<p>It is important to remember that developers who <em>write</em> scripts in Python are
often <em>not</em> experienced in Python, or Python packaging. They are often systems
administrators, or data analysts, who may simply be using Python as a “better
batch file”. For such users, the TOML format is extremely likely to be
unfamiliar, and the syntax will be obscure to them, and not particularly
intuitive. Such developers may well be copying dependency specifiers from
sources such as Stack Overflow, without really understanding them. Having to
embed such a requirement into a TOML structure is an additional complexity –
and it is important to remember that the goal here is to make using 3rd party
libraries <em>easy</em> for such users.</p>
<p>Furthermore, TOML, by its nature, is a flexible format intended to support very
general data structures. There are <em>many</em> ways of writing a simple list of
strings in it, and it will not be clear to inexperienced users which form to use.</p>
<p>And finally, there will be tools that expect to <em>write</em> dependency data into
scripts – for example, an IDE with a feature that automatically adds an import
and a dependency specifier when you reference a library function. While
libraries exist that allow editing TOML data, they are not always good at
preserving the user’s layout, which could include comments, specific formatting,
etc. Even if libraries exist which do an effective job at this, expecting all
tools to use such a library is a significant imposition on code supporting this
PEP.</p>
<p>By choosing a simple, line-based format with no quoting rules, dependency data
is easy to read (for humans and tools) and easy to write. The format doesn’t
have the flexibility of something like TOML, but the use case simply doesn’t
demand that sort of flexibility.</p>
</section>
<section id="why-not-embed-a-pyproject-toml-file-in-the-script">
<h3><a class="toc-backref" href="#why-not-embed-a-pyproject-toml-file-in-the-script" role="doc-backlink">Why not embed a <code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code> file in the script?</a></h3>
<p>First of all, <code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code> is a TOML based format, so all of the previous
concerns around TOML as a format apply. However, <code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code> is a
standard used by Python packaging, and re-using an existing standard is a
reasonable suggestion that deserves to be addressed on its own merits.</p>
<p>The first issue is that the suggestion rarely implies that <em>all</em> of
<code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code> is to be supported for scripts. A script is not intended to
be “built” into any sort of distributable artifact like a wheel (see below for
more on this point), so the <code class="docutils literal notranslate"><span class="pre">[build-system]</span></code> section of <code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code>
makes little sense, for example. And while the tool-specific sections of
<code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code> might be useful for scripts, it’s not at all clear that a
tool like <a class="reference external" href="https://beta.ruff.rs/docs/">ruff</a> would want to support per-file
configuration in this way, leading to confusion when users <em>expect</em> it to work,
but it doesn’t. Furthermore, this sort of tool-specific configuration is just as
useful for individual files in a larger project, so we have to consider what it
would mean to embed a <code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code> into a single file in a larger project
that has its own <code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code>.</p>
<p>In addition, <code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code> is currently focused on projects that are to be
built into wheels. There is <a class="reference external" href="https://discuss.python.org/t/projects-that-arent-meant-to-generate-a-wheel-and-pyproject-toml/29684">an ongoing discussion</a>
about how to use <code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code> for projects that are not intended to be
built as wheels, and until that question is resolved (which will likely require
some PEPs of its own) it seems premature to be discussing embedding
<code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code> into scripts, which are <em>definitely</em> not intended to be built
and distributed in that manner.</p>
<p>The conclusion, therefore (which has been stated explicitly in some, but not
all, cases) is that this proposal is intended to mean that we would embed <em>part
of</em> <code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code>. Typically this is the <code class="docutils literal notranslate"><span class="pre">[project]</span></code> section from
<a class="pep reference internal" href="../pep-0621" title="PEP 621 – Storing project metadata in pyproject.toml">PEP 621</a>, or even just the <code class="docutils literal notranslate"><span class="pre">dependencies</span></code> item from that section.</p>
<p>At this point, the first issue is that by framing the proposal as “embedding
<code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code>”, we would be encouraging the sort of confusion discussed in
the previous paragraphs - developers will expect the full capabilities of
<code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code>, and be confused when there are differences and limitations.
It would be better, therefore, to consider this suggestion as simply being a
proposal to use an embedded TOML format, but specifically re-using the
<em>structure</em> of a particular part of <code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code>. The problem then becomes
how we describe that structure, <em>without</em> causing confusion for people familiar
with <code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code>. If we describe it with reference to <code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code>,
the link is still there. But if we describe it in isolation, people will be
confused by the “similar but different” nature of the structure.</p>
<p>It is also important to remember that a key part of the target audience for this
proposal is developers who are simply using Python as a “better batch file”
solution. These developers will generally not be familiar with Python packaging
and its conventions, and are often the people most critical of the “complexity”
and “difficulty” of packaging solutions. As a result, proposals based on those
existing solutions are likely to be unwelcome to that audience, and could easily
result in people simply continuing to use existing adhoc solutions, and ignoring
the standard that was intended to make their lives easier.</p>
</section>
<section id="why-not-just-set-up-a-python-project-with-a-pyproject-toml">
<h3><a class="toc-backref" href="#why-not-just-set-up-a-python-project-with-a-pyproject-toml" role="doc-backlink">Why not just set up a Python project with a <code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code>?</a></h3>
<p>Again, a key issue here is that the target audience for this proposal is people
writing scripts which aren’t intended for distribution. Sometimes scripts will
be “shared”, but this is far more informal than “distribution” - it typically
involves sending a script via an email with some written instructions on how to
run it, or passing someone a link to a gist.</p>
<p>Expecting such users to learn the complexities of Python packaging is a
significant step up in complexity, and would almost certainly give the
impression that “Python is too hard for scripts”.</p>
<p>In addition, if the expectation here is that the <code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code> will somehow
be designed for running scripts in place, that’s a new feature of the standard
that doesn’t currently exist. At a minimum, this isn’t a reasonable suggestion
until the <a class="reference external" href="https://discuss.python.org/t/projects-that-arent-meant-to-generate-a-wheel-and-pyproject-toml/29684">current discussion on Discourse</a> about
using <code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code> for projects that won’t be distributed as wheels is
resolved. And even then, it doesn’t address the “sending someone a script in a
gist or email” use case.</p>
</section>
<section id="why-not-use-a-requirements-file-for-dependencies">
<h3><a class="toc-backref" href="#why-not-use-a-requirements-file-for-dependencies" role="doc-backlink">Why not use a requirements file for dependencies?</a></h3>
<p>Putting your requirements in a requirements file, doesn’t require a PEP. You can
do that right now, and in fact it’s quite likely that many adhoc solutions do
this. However, without a standard, there’s no way of knowing how to locate a
script’s dependency data. And furthermore, the requirements file format is
pip-specific, so tools relying on it are depending on a pip implementation
detail.</p>
<p>So in order to make a standard, two things would be required:</p>
<ol class="arabic simple">
<li>A standardised replacement for the requirements file format.</li>
<li>A standard for how to locate the requiements file for a given script.</li>
</ol>
<p>The first item is a significant undertaking. It has been discussed on a number
of occasions, but so far no-one has attempted to actually do it. The most likely
approach would be for standards to be developed for individual use cases
currently addressed with requirements files. One option here would be for this
PEP to simply define a new file format which is simply a text file containing
<a class="pep reference internal" href="../pep-0508" title="PEP 508 – Dependency specification for Python Software Packages">PEP 508</a> requirements, one per line. That would just leave the question of how
to locate that file.</p>
<p>The “obvious” solution here would be to do something like name the file the same
as the script, but with a <code class="docutils literal notranslate"><span class="pre">.reqs</span></code> extension (or something similar). However,
this still requires <em>two</em> files, where currently only a single file is needed,
and as such, does not match the “better batch file” model (shell scripts and
batch files are typically self-contained). It requires the developer to remember
to keep the two files together, and this may not always be possible. For
example, system administration policies may require that <em>all</em> files in a
certain directory are executable (the Linux filesystem standards require this of
<code class="docutils literal notranslate"><span class="pre">/usr/bin</span></code>, for example). And some methods of sharing a script (for example,
publishing it on a text file sharing service like Github’s gist, or a corporate
intranet) may not allow for deriving the location of an associated requirements
file from the script’s location (tools like <code class="docutils literal notranslate"><span class="pre">pipx</span></code> support running a script
directly from a URL, so “download and unpack a zip of the script and its
dependencies” may not be an appropriate requirement).</p>
<p>Essentially, though, the issue here is that there is an explicitly stated
requirement that the format supports storing dependency data <em>in the script file
itself</em>. Solutions that don’t do that are simply ignoring that requirement.</p>
</section>
<section id="why-not-use-possibly-restricted-python-syntax">
<h3><a class="toc-backref" href="#why-not-use-possibly-restricted-python-syntax" role="doc-backlink">Why not use (possibly restricted) Python syntax?</a></h3>
<p>This would typically involve storing the dependencies as a (runtime) list
variable with a conventional name, such as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">__requires__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;requests&quot;</span><span class="p">,</span>
    <span class="s2">&quot;click&quot;</span><span class="p">,</span>
<span class="p">]</span>
</pre></div>
</div>
<p>Other suggestions include a static multi-line string, or including the
dependencies in the script’s docstring.</p>
<p>The most significant problem with this proposal is that it requires all
consumers of the dependency data to implement a Python parser. Even if the
syntax is restricted, the <em>rest</em> of the script will use the full Python syntax,
and trying to define a syntax which can be successfully parsed in isolation from
the surrounding code is likely to be extremely difficult and error-prone.</p>
<p>Furthermore, Python’s syntax changes in every release. If extracting dependency
data needs a Python parser, the parser will need to know which version of Python
the script is written for, and the overhead for a generic tool of having a
parser that can handle <em>multiple</em> versions of Python is unsustainable.</p>
<p>Even if the above issues could be addressed, the format would give the
impression that the data could be altered at runtime. However, this is not the
case in general, and code that tries to do so will encounter unexpected and
confusing behaviour.</p>
<p>And finally, there is no evidence that having dependency data available at
runtime is of any practical use. Should such a use be found, it is simple enough
to get the data by parsing the source - <code class="docutils literal notranslate"><span class="pre">read_dependency_block(__file__)</span></code>.</p>
<p>It is worth noting, though, that the <code class="docutils literal notranslate"><span class="pre">pip-run</span></code> utility does implement (an
extended form of) this approach. <a class="reference external" href="https://github.com/jaraco/pip-run/issues/44">Further discussion</a> of
the <code class="docutils literal notranslate"><span class="pre">pip-run</span></code> design is available on the project’s issue tracker.</p>
</section>
<section id="should-scripts-be-able-to-specify-a-package-index">
<h3><a class="toc-backref" href="#should-scripts-be-able-to-specify-a-package-index" role="doc-backlink">Should scripts be able to specify a package index?</a></h3>
<p>Dependency metadata is about <em>what</em> package the code depends on, and not <em>where</em>
that package comes from. There is no difference here between metadata for
scripts, and metadata for distribution packages (as defined in
<code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code>). In both cases, dependencies are given in “abstract” form,
without specifying how they are obtained.</p>
<p>Some tools that use the dependency information may, of course, need to locate
concrete dependency artifacts - for example if they expect to create an
environment containing those dependencies. But the way they choose to do that
will be closely linked to the tool’s UI in general, and this PEP does not try to
dictate the UI for tools.</p>
<p>There is more discussion of this point, and in particular of the UI choices made
by the <code class="docutils literal notranslate"><span class="pre">pip-run</span></code> tool, in <a class="reference external" href="https://github.com/jaraco/pip-run/issues/44">the previously mentioned pip-run issue</a>.</p>
</section>
<section id="what-about-local-dependencies">
<h3><a class="toc-backref" href="#what-about-local-dependencies" role="doc-backlink">What about local dependencies?</a></h3>
<p>These can be handled without needing special metadata and tooling, simply by
adding the location of the dependencies to <code class="docutils literal notranslate"><span class="pre">sys.path</span></code>. This PEP simply isn’t
needed for this case. If, on the other hand, the “local dependencies” are actual
distributions which are published locally, they can be specified as usual with a
<a class="pep reference internal" href="../pep-0508" title="PEP 508 – Dependency specification for Python Software Packages">PEP 508</a> requirement, and the local package index specified when running a
tool by using the tool’s UI for that.</p>
</section>
</section>
<section id="open-issues">
<h2><a class="toc-backref" href="#open-issues" role="doc-backlink">Open Issues</a></h2>
<p>None at this point.</p>
</section>
<section id="copyright">
<h2><a class="toc-backref" href="#copyright" role="doc-backlink">Copyright</a></h2>
<p>This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.</p>
</section>
</section>
<hr class="docutils" />
<p>Source: <a class="reference external" href="https://github.com/python/peps/blob/main/pep-0722.rst">https://github.com/python/peps/blob/main/pep-0722.rst</a></p>
<p>Last modified: <a class="reference external" href="https://github.com/python/peps/commits/main/pep-0722.rst">2023-08-03 21:14:28+00:00 GMT</a></p>

        </article>
        <nav id="pep-sidebar">
            <h2>Contents</h2>
            <ul>
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#motivation">Motivation</a></li>
<li><a class="reference internal" href="#rationale">Rationale</a></li>
<li><a class="reference internal" href="#specification">Specification</a><ul>
<li><a class="reference internal" href="#example">Example</a></li>
</ul>
</li>
<li><a class="reference internal" href="#backwards-compatibility">Backwards Compatibility</a></li>
<li><a class="reference internal" href="#security-implications">Security Implications</a></li>
<li><a class="reference internal" href="#how-to-teach-this">How to Teach This</a></li>
<li><a class="reference internal" href="#recommendations">Recommendations</a></li>
<li><a class="reference internal" href="#reference-implementation">Reference Implementation</a></li>
<li><a class="reference internal" href="#rejected-ideas">Rejected Ideas</a><ul>
<li><a class="reference internal" href="#why-not-include-other-metadata">Why not include other metadata?</a></li>
<li><a class="reference internal" href="#why-not-use-a-more-standard-data-format-e-g-toml">Why not use a more standard data format (e.g., TOML)?</a></li>
<li><a class="reference internal" href="#why-not-embed-a-pyproject-toml-file-in-the-script">Why not embed a <code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code> file in the script?</a></li>
<li><a class="reference internal" href="#why-not-just-set-up-a-python-project-with-a-pyproject-toml">Why not just set up a Python project with a <code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code>?</a></li>
<li><a class="reference internal" href="#why-not-use-a-requirements-file-for-dependencies">Why not use a requirements file for dependencies?</a></li>
<li><a class="reference internal" href="#why-not-use-possibly-restricted-python-syntax">Why not use (possibly restricted) Python syntax?</a></li>
<li><a class="reference internal" href="#should-scripts-be-able-to-specify-a-package-index">Should scripts be able to specify a package index?</a></li>
<li><a class="reference internal" href="#what-about-local-dependencies">What about local dependencies?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#open-issues">Open Issues</a></li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>

            <br>
            <a id="source" href="https://github.com/python/peps/blob/main/pep-0722.rst">Page Source (GitHub)</a>
        </nav>
    </section>
    <script src="../_static/colour_scheme.js"></script>
    <script src="../_static/wrap_tables.js"></script>
    <script src="../_static/sticky_banner.js"></script>
</body>
</html>